---
title: "SIAMCAT: Statistical Inference of Associations between Microbial
Communities And host phenoTypes"
author:
-   name: "Konrad Zych, Jakob Wirbel, and Georg Zeller"
    affiliation: "EMBL Heidelberg"
    email: "georg.zeller@embl.de"
date: "Date last modified: 2018-05-16"
output: BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{SIAMCAT basic vignette}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{ASCII}
---

# About this vignette

This vignette aims to be a short tutorial for the main functionalities of
`SIAMCAT`. Examples of additional workflows or more detailed tutorials can
be found in other vignettes (see the
[BioConductor page](https://bioconductor.org/packages/SIAMCAT)).

`SIAMCAT` is part of the suite of computational microbiome analysis tools
hosted at [EMBL](https://www.embl.org) by the groups of
[Peer Bork](https://www.embl.de/research/units/scb/bork/index.html) and
[Georg Zeller](https://www.embl.de/research/units/scb/zeller/index.html). Find
out more at [EMBL-microbiome tools](http://microbiome-tools.embl.de/).


# Introduction

Associations between microbiome and host phenotypes are ideally described by
quantitative models able to predict host status from microbiome composition.
`SIAMCAT` can do so for data from hundreds of thousands of microbial taxa, gene
families, or metabolic pathways over hundreds of samples. `SIAMCAT` produces
graphical output for convenient assessment of the quality of the input data and
statistical associations, for model diagnostics and inference revealing the
most predictive microbial biomarkers.

# Quick Start

For this vignette, we use an example dataset included in the `SIAMCAT` package.
The data comes from the publication of
[Zeller et al](http://europepmc.org/abstract/MED/25432777), which demonstrated
the potential of microbial markers in fecal samples to distinguish patients
with colorectal cancer (CRC) from healthy controls.

```{r load_files, message=FALSE}
library(SIAMCAT)

data("feat_crc_zeller", package="SIAMCAT")
data("meta_crc_zeller", package="SIAMCAT")
```

Firstly, the package needs a feature matrix (can be either a matrix, a
dataframe, or a `phyloseq-otu_table`), which contains values for different
features (in rows) for different samples (in columns). For example, the
feature matrix included here contains relative abundances for bacterial
species calculated with the [mOTU profiler](motu-tool.org) for several
141 samples:

```{r show_features}
feat.crc.zeller[1:3, 1:3]
dim(feat.crc.zeller)
```

Secondly, we also have metadata about the samples in another data.frame:

```{r show_meta}
head(meta.crc.zeller)
```

From the `Group` column, we can construct a label object to tell `SIAMCAT`,
which samples are cancer cases and which are healthy controls.

```{r create_label}
label.crc.zeller <- create.label.from.metadata(meta=meta.crc.zeller,
    column='Group', case='CRC')
```

Now we have all the ingredients to create a `SIAMCAT` object. Please have a
look at the [vignette about input formats](SIAMCAT_read-in.html) for more
information about supported formats and other ways to create a `SIAMCAT` object.

```{r start}
siamcat <- siamcat(feat=feat.crc.zeller,
    label=label.crc.zeller,
    meta=meta.crc.zeller)
```

A few information about the `siamcat` object can be accessed with the `show`
function from `phyloseq` (`SIAMCAT` builds on the `phyloseq` data structure):

```{r show_siamcat}
show(siamcat)
```


# Association Testing

Since we have quite a lot of microbial markers in the dataset at the moment, we
can perform unsupervised feature selection using the function `filter.features`.

```{r filter_feat}
siamcat <- filter.features(siamcat, filter.method = 'abundance', cutoff = 0.001)
```

Associations between microbial markers and the label can be tested
with the `check.associations` function. The function computes for each marker
the significance using a non-parametric Wilcoxon test and different effect
sizes for the association (e.g. AUC or fold change).

```{r check_associations, eval=FALSE}
siamcat <- check.associations(
    siamcat,
    sort.by = 'fc',
    fn.plot = 'assoc.pdf',
    alpha = 0.05,
    mult.corr = "fdr",
    detect.lim = 10 ^-6,
    max.show = 50,
    plot.type = "quantile.box",
    panels = c("fc", "prevalence", "auroc"),
    verbose = 0)
```
The function produces a pdf file as output, since the plot is optimized for a
landscape DIN-A4 layout, but can also used to plot on an active graphic device,
e.g. in RStudio. The resulting plot then looks like that:
![Association Plot]('./association_plot.png')


# Model Building

One strength of `SIAMCAT` is the versatile but easy-to-use interface for the
construction of machine learning models on the basis of microbial markers.
`SIAMCAT` contains functions for data normalization, splitting the data into
cross-validation folds, training the model, and making predictions based on
cross-validation instances and the trained models.

## Data Normalization

Data normalization is performed with the `normalize.features` function.
Several control options are available, for example a choice of the normalization
method from `log.unit`, `log.std`, `rank.unit`, `rank.std` and `log.clr` or
additional parameters. Here, we use the `log.unit` method:

```{r normalize_feat}
siamcat <- normalize.features(
    siamcat,
    norm.method = "log.unit",
    norm.param = list(
        log.n0 = 1e-06,
        n.p = 2,
        norm.margin = 1
    )
)
```

## Prepare Cross-Validation

Preparation of the cross-validation fold is a crucial step in machine learning.
`SIAMCAT` greatly simplifies the set-up of cross-validation schemes, including
stratification of samples or keeping samples inseperable based on metadata.
For this small example, we choose a twice-repeated 5-fold cross-validation
scheme. The data-split will be saved in the `data_split` slot of the `siamcat`
object.

```{r data_split}
siamcat <-  create.data.split(
    siamcat,
    num.folds = 5,
    num.resample = 2
)
```

## Model Training

The actual model training is performed using the function `train.model`.
Again, multiple options for customization are available, ranging from the
machine learning method to the measure for model selection or customizable
parameter set for hyperparameter tuning.

```{r train_model}
siamcat <- train.model(
    siamcat,
    method = "lasso",
    verbose = 0
)
```

The models are saved in the `model_list` slot of the `siamcat` object. The
model building is performed using the `mlr` R package. All models can easily be
accessed.

```{r show_models}
# get information about the model type
model_type(siamcat)

# access the models
models <- models(siamcat)
models[[1]]
```

## Make Predictions

Using the data-split and the models trained in previous step, we can use the
function `make.predictions` in order to apply the models on the test instances
in the data-split. The predictions will be saved in the `pred_matrix` slot of
the `siamcat` object.

```{r make_predictions}
siamcat <- make.predictions(siamcat, verbose=0)
pred_matrix <- pred_matrix(siamcat)
head(pred_matrix)
```


# Model Evaluation and Interpretation

In the final part, we want to find out how well the model performed and which
microbial markers had been selected in the model. In order to do so, we first
calculate how well the predictions fit the real data using the function
`evaluate.predictions`. This function calculates the Area Under the Receiver
Operating Characteristic (ROC) Curve (AU-ROC) and the Precision Recall (PR)
Curve for each resampled cross-validation run.

```{r eval_predictions}
siamcat <-  evaluate.predictions(siamcat)
```

## Evaluation plot

To plot the results of the evaluation, we can use the function
`model.evaluation.plot`, which produces a pdf-file showing the ROC and PR
Curves for the different resamples runs as well as the mean ROC and PR Curve.

```{r eval_plot, fig.height=6, fig.width=6, fig.align='center', message=FALSE}
model.evaluation.plot(siamcat)
```

## Interpretation plot

The final plot produced by `SIAMCAT` is the model interpretation plot, created
by the `model.interpretation.plot` function. The plot shows for the top
selected features the

+ model weights (and how robust they are) as a barplot,

+ a heatmap with the z-scores or fold changes for the top selected features,
and

+ a boxplot showing the proportions of weight per model which is captured by the
top selected features.

Additionally, the distribution of metadata is shown in a heatmap below.

The function again produces a pdf-file optimized for a landscape DIN-A4
plotting region.

```{r eval=FALSE}
model.interpretation.plot(
    siamcat,
    fn.plot = 'interpretation.pdf',
    consens.thres = 0.5,
    norm.models = TRUE,
    limits = c(-3, 3),
    heatmap.type = 'zscore',
    verbose = 2
)
```

The resulting plot looks like this:

![Model Interpretation Plot](./interpretation_plot.png)


# Session Info

```{r}
sessionInfo()
```
